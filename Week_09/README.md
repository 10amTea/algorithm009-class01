学习笔记

## 课后习题

[不同路径 2 ](https://leetcode-cn.com/problems/unique-paths-ii/) 状态转移方程

```txt
如果网格(i,j)上有障碍物，则dp[i][j]值为0，表示走到该格子的方法数为0；
否则网格(i,j)可以从网格(i−1,j)或者网格(i,j−1)走过来，因此走到该格子的方法数为走到网格(i-1,j)和网格 (i,j−1)的方法数之和，即dp[i,j]=dp[i−1,j]+dp[i,j−1]。

状态转移方程如下：
dp[i][j] = 0; // (i,j)上无障碍物
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // (i,j)上有障碍物

```

## 股票动态规划

**状态转移框架**

```
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max(   选择 rest  ,             选择 sell      )
解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max(   选择 rest  ,           选择 buy         )
解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。
```

状态转移方程总结一下：

```
base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

```
我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。
```

